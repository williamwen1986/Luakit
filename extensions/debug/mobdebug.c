#include "lua.h"
#include "lauxlib.h"
#include "luasocket_scripts.h"

static const char *lua_mobdebug ={"--\n"
    "-- MobDebug -- Lua remote debugger\n"
    "-- Copyright 2011-15 Paul Kulchenko\n"
    "-- Based on RemDebug 1.0 Copyright Kepler Project 2005\n"
    "--\n"
    "\n"
    "-- use loaded modules or load explicitly on those systems that require that\n"
    "local require = require\n"
    "local io = io or require \"io\"\n"
    "local table = table or require \"table\"\n"
    "local string = string or require \"string\"\n"
    "local coroutine = coroutine or require \"coroutine\"\n"
    "local debug = require \"debug\"\n"
    "function string:split(sep)\n"
    "    local sep, fields = sep or ':', {}\n"
    "    local pattern = string.format('([^%s]+)', sep)\n"
    "    self:gsub(pattern, function (c) fields[#fields + 1] = c end)\n"
    "    return fields\n"
    "end\n"
    "-- protect require \"os\" as it may fail on embedded systems without os module\n"
    "local os = os or (function(module)\n"
    "  local ok, res = pcall(require, module)\n"
    "  return ok and res or nil\n"
    "end)(\"os\")\n"
    "\n"
    "local mobdebug = {\n"
    "  _NAME = \"mobdebug\",\n"
    "  _VERSION = 0.627,\n"
    "  _COPYRIGHT = \"Paul Kulchenko\",\n"
    "  _DESCRIPTION = \"Mobile Remote Debugger for the Lua programming language\",\n"
    "  port = os and os.getenv and tonumber((os.getenv(\"MOBDEBUG_PORT\"))) or 8172,\n"
    "  checkcount = 200,\n"
    "  yieldtimeout = 0.02, -- yield timeout (s)\n"
    "  connecttimeout = 2, -- connect timeout (s)\n"
    "}\n"
    "\n"
    "local error = error\n"
    "local getfenv = getfenv\n"
    "local setfenv = setfenv\n"
    "local loadstring = loadstring or load -- \"load\" replaced \"loadstring\" in Lua 5.2\n"
    "local pairs = pairs\n"
    "local setmetatable = setmetatable\n"
    "local tonumber = tonumber\n"
    "local unpack = table.unpack or unpack\n"
    "local rawget = rawget\n"
    "local gsub, sub, find = string.gsub, string.sub, string.find\n"
    "\n"
    "-- if strict.lua is used, then need to avoid referencing some global\n"
    "-- variables, as they can be undefined;\n"
    "-- use rawget to avoid complaints from strict.lua at run-time.\n"
    "-- it's safe to do the initialization here as all these variables\n"
    "-- should get defined values (if any) before the debugging starts.\n"
    "-- there is also global 'wx' variable, which is checked as part of\n"
    "-- the debug loop as 'wx' can be loaded at any time during debugging.\n"
    "local genv = _G or _ENV\n"
    "local jit = rawget(genv, \"jit\")\n"
    "local MOAICoroutine = rawget(genv, \"MOAICoroutine\")\n"
    "\n"
    "-- ngx_lua debugging requires a special handling as its coroutine.*\n"
    "-- methods use a different mechanism that doesn't allow resume calls\n"
    "-- from debug hook handlers.\n"
    "-- Instead, the \"original\" coroutine.* methods are used.\n"
    "-- `rawget` needs to be used to protect against `strict` checks, but\n"
    "-- ngx_lua hides those in a metatable, so need to use that.\n"
    "local metagindex = getmetatable(genv) and getmetatable(genv).__index\n"
    "local ngx = type(metagindex) == \"table\" and metagindex.rawget and metagindex:rawget(\"ngx\") or nil\n"
    "local corocreate = ngx and coroutine._create or coroutine.create\n"
    "local cororesume = ngx and coroutine._resume or coroutine.resume\n"
    "local coroyield = ngx and coroutine._yield or coroutine.yield\n"
    "local corostatus = ngx and coroutine._status or coroutine.status\n"
    "local corowrap = coroutine.wrap\n"
    "\n"
    "if not setfenv then -- Lua 5.2+\n"
    "  -- based on http://lua-users.org/lists/lua-l/2010-06/msg00314.html\n"
    "  -- this assumes f is a function\n"
    "  local function findenv(f)\n"
    "    local level = 1\n"
    "    repeat\n"
    "      local name, value = debug.getupvalue(f, level)\n"
    "      if name == '_ENV' then return level, value end\n"
    "      level = level + 1\n"
    "    until name == nil\n"
    "    return nil end\n"
    "  getfenv = function (f) return(select(2, findenv(f)) or _G) end\n"
    "  setfenv = function (f, t)\n"
    "    local level = findenv(f)\n"
    "    if level then debug.setupvalue(f, level, t) end\n"
    "    return f end\n"
    "end\n"
    "\n"
    "-- check for OS and convert file names to lower case on windows\n"
    "-- (its file system is case insensitive, but case preserving), as setting a\n"
    "-- breakpoint on x:\\Foo.lua will not work if the file was loaded as X:\\foo.lua.\n"
    "-- OSX and Windows behave the same way (case insensitive, but case preserving).\n"
    "-- OSX can be configured to be case-sensitive, so check for that. This doesn't\n"
    "-- handle the case of different partitions having different case-sensitivity.\n"
    "local win = os and os.getenv and (os.getenv('WINDIR') or (os.getenv('OS') or ''):match('[Ww]indows')) and true or false\n"
    "local mac = not win and (os and os.getenv and os.getenv('DYLD_LIBRARY_PATH') or not io.open(\"/proc\")) and true or false\n"
    "local iscasepreserving = win or (mac and io.open('/library') ~= nil)\n"
    "\n"
    "-- turn jit off based on Mike Pall's comment in this discussion:\n"
    "-- http://www.freelists.org/post/luajit/Debug-hooks-and-JIT,2\n"
    "-- \"You need to turn it off at the start if you plan to receive\n"
    "-- reliable hook calls at any later point in time.\"\n"
    "if jit and jit.off then jit.off() end\n"
    "\n"
    "local socket = require \"socket\"\n"
    "local coro_debugger\n"
    "local coro_debugee\n"
    "local coroutines = {}; setmetatable(coroutines, {__mode = \"k\"}) -- \"weak\" keys\n"
    "local events = { BREAK = 1, WATCH = 2, RESTART = 3, STACK = 4 }\n"
    "local breakpoints = {}\n"
    "local watches = {}\n"
    "local lastsource\n"
    "local lastfile\n"
    "local watchescnt = 0\n"
    "local abort -- default value is nil; this is used in start/loop distinction\n"
    "local seen_hook = false\n"
    "local checkcount = 0\n"
    "local step_into = false\n"
    "local step_over = false\n"
    "local step_level = 0\n"
    "local stack_level = 0\n"
    "local server\n"
    "local buf\n"
    "local outputs = {}\n"
    "local iobase = {print = print}\n"
    "local basedir = \"\"\n"
    "local deferror = \"execution aborted at default debugee\"\n"
    "local debugee = function ()\n"
    "  local a = 1\n"
    "  for _ = 1, 10 do a = a + 1 end\n"
    "  error(deferror)\n"
    "end\n"
    "local function q(s) return string.gsub(s, '([%(%)%.%%%+%-%*%?%[%^%$%]])','%%%1') end\n"
    "\n"
    "local serpent = (function() ---- include Serpent module for serialization\n"
    "local n, v = \"serpent\", 0.284 -- (C) 2012-15 Paul Kulchenko; MIT License\n"
    "local c, d = \"Paul Kulchenko\", \"Lua serializer and pretty printer\"\n"
    "local snum = {[tostring(1/0)]='1/0 --[[math.huge]]',[tostring(-1/0)]='-1/0 --[[-math.huge]]',[tostring(0/0)]='0/0'}\n"
    "local badtype = {thread = true, userdata = true, cdata = true}\n"
    "local getmetatable = debug and debug.getmetatable or getmetatable\n"
    "local keyword, globals, G = {}, {}, (_G or _ENV)\n"
    "for _,k in ipairs({'and', 'break', 'do', 'else', 'elseif', 'end', 'false',\n"
    "  'for', 'function', 'goto', 'if', 'in', 'local', 'nil', 'not', 'or', 'repeat',\n"
    "  'return', 'then', 'true', 'until', 'while'}) do keyword[k] = true end\n"
    "for k,v in pairs(G) do globals[v] = k end -- build func to name mapping\n"
    "for _,g in ipairs({'coroutine', 'debug', 'io', 'math', 'string', 'table', 'os'}) do\n"
    "  for k,v in pairs(type(G[g]) == 'table' and G[g] or {}) do globals[v] = g..'.'..k end end\n"
    "\n"
    "local function s(t, opts)\n"
    "  local name, indent, fatal, maxnum = opts.name, opts.indent, opts.fatal, opts.maxnum\n"
    "  local sparse, custom, huge = opts.sparse, opts.custom, not opts.nohuge\n"
    "  local space, maxl = (opts.compact and '' or ' '), (opts.maxlevel or math.huge)\n"
    "  local iname, comm = '_'..(name or ''), opts.comment and (tonumber(opts.comment) or math.huge)\n"
    "  local numformat = opts.numformat or \"%.17g\"\n"
    "  local seen, sref, syms, symn = {}, {'local '..iname..'={}'}, {}, 0\n"
    "  local function gensym(val) return '_'..(tostring(tostring(val)):gsub(\"[^%w]\",\"\"):gsub(\"(%d%w+)\",\n"
    "    -- tostring(val) is needed because __tostring may return a non-string value\n"
    "    function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end)) end\n"
    "  local function safestr(s) return type(s) == \"number\" and tostring(huge and snum[tostring(s)] or numformat:format(s))\n"
    "    or type(s) ~= \"string\" and tostring(s) -- escape NEWLINE/010 and EOF/026\n"
    "    or (\"%q\"):format(s):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\") end\n"
    "  local function comment(s,l) return comm and (l or 0) < comm and ' --[['..select(2, pcall(tostring, s))..']]' or '' end\n"
    "  local function globerr(s,l) return globals[s] and globals[s]..comment(s,l) or not fatal\n"
    "    and safestr(select(2, pcall(tostring, s))) or error(\"Can't serialize \"..tostring(s)) end\n"
    "  local function safename(path, name) -- generates foo.bar, foo[3], or foo['b a r']\n"
    "    local n = name == nil and '' or name\n"
    "    local plain = type(n) == \"string\" and n:match(\"^[%l%u_][%w_]*$\") and not keyword[n]\n"
    "    local safe = plain and n or '['..safestr(n)..']'\n"
    "    return (path or '')..(plain and path and '.' or '')..safe, safe end\n"
    "  local alphanumsort = type(opts.sortkeys) == 'function' and opts.sortkeys or function(k, o, n) -- k=keys, o=originaltable, n=padding\n"
    "    local maxn, to = tonumber(n) or 12, {number = 'a', string = 'b'}\n"
    "    local function padnum(d) return (\"%0\"..tostring(maxn)..\"d\"):format(tonumber(d)) end\n"
    "    table.sort(k, function(a,b)\n"
    "      -- sort numeric keys first: k[key] is not nil for numerical keys\n"
    "      return (k[a] ~= nil and 0 or to[type(a)] or 'z')..(tostring(a):gsub(\"%d+\",padnum))\n"
    "           < (k[b] ~= nil and 0 or to[type(b)] or 'z')..(tostring(b):gsub(\"%d+\",padnum)) end) end\n"
    "  local function val2str(t, name, indent, insref, path, plainindex, level)\n"
    "    local ttype, level, mt = type(t), (level or 0), getmetatable(t)\n"
    "    local spath, sname = safename(path, name)\n"
    "    local tag = plainindex and\n"
    "      ((type(name) == \"number\") and '' or name..space..'='..space) or\n"
    "      (name ~= nil and sname..space..'='..space or '')\n"
    "    if seen[t] then -- already seen this element\n"
    "      sref[#sref+1] = spath..space..'='..space..seen[t]\n"
    "      return tag..'nil'..comment('ref', level) end\n"
    "    -- protect from those cases where __tostring may fail\n"
    "    if type(mt) == 'table' and pcall(function() return mt.__tostring and mt.__tostring(t) end)\n"
    "    and (mt.__serialize or mt.__tostring) then -- knows how to serialize itself\n"
    "      seen[t] = insref or spath\n"
    "      if mt.__serialize then t = mt.__serialize(t) else t = tostring(t) end\n"
    "      ttype = type(t) end -- new value falls through to be serialized\n"
    "    if ttype == \"table\" then\n"
    "      if level >= maxl then return tag..'{}'..comment('max', level) end\n"
    "      seen[t] = insref or spath\n"
    "      if next(t) == nil then return tag..'{}'..comment(t, level) end -- table empty\n"
    "      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}\n"
    "      for key = 1, maxn do o[key] = key end\n"
    "      if not maxnum or #o < maxnum then\n"
    "        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables\n"
    "        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end\n"
    "      if maxnum and #o > maxnum then o[maxnum+1] = nil end\n"
    "      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end\n"
    "      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)\n"
    "      for n, key in ipairs(o) do\n"
    "        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse\n"
    "        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\n"
    "        or opts.keyallow and not opts.keyallow[key]\n"
    "        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\n"
    "        or sparse and value == nil then -- skipping nils; do nothing\n"
    "        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then\n"
    "          if not seen[key] and not globals[key] then\n"
    "            sref[#sref+1] = 'placeholder'\n"
    "            local sname = safename(iname, gensym(key)) -- iname is table for local variables\n"
    "            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\n"
    "          sref[#sref+1] = 'placeholder'\n"
    "          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'\n"
    "          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))\n"
    "        else\n"
    "          out[#out+1] = val2str(value,key,indent,insref,seen[t],plainindex,level+1)\n"
    "        end\n"
    "      end\n"
    "      local prefix = string.rep(indent or '', level)\n"
    "      local head = indent and '{\\n'..prefix..indent or '{'\n"
    "      local body = table.concat(out, ','..(indent and '\\n'..prefix..indent or space))\n"
    "      local tail = indent and \"\\n\"..prefix..'}' or '}'\n"
    "      return (custom and custom(tag,head,body,tail) or tag..head..body..tail)..comment(t, level)\n"
    "    elseif badtype[ttype] then\n"
    "      seen[t] = insref or spath\n"
    "      return tag..globerr(t, level)\n"
    "    elseif ttype == 'function' then\n"
    "      seen[t] = insref or spath\n"
    "      local ok, res = pcall(string.dump, t)\n"
    "      local func = ok and ((opts.nocode and \"function() --[[..skipped..]] end\" or\n"
    "        \"((loadstring or load)(\"..safestr(res)..\",'@serialized'))\")..comment(t, level))\n"
    "      return tag..(func or globerr(t, level))\n"
    "    else return tag..safestr(t) end -- handle all other types\n"
    "  end\n"
    "  local sepr = indent and \"\\n\" or \";\"..space\n"
    "  local body = val2str(t, name, indent) -- this call also populates sref\n"
    "  local tail = #sref>1 and table.concat(sref, sepr)..sepr or ''\n"
    "  local warn = opts.comment and #sref>1 and space..\"--[[incomplete output with shared/self-references skipped]]\" or ''\n"
    "  return not name and body..warn or \"do local \"..body..sepr..tail..\"return \"..name..sepr..\"end\"\n"
    "end\n"
    "\n"
    "local function deserialize(data, opts)\n"
    "  local env = (opts and opts.safe == false) and G\n"
    "    or setmetatable({}, {\n"
    "        __index = function(t,k) return t end,\n"
    "        __call = function(t,...) error(\"cannot call functions\") end\n"
    "      })\n"
    "  local f, res = (loadstring or load)('return '..data, nil, nil, env)\n"
    "  if not f then f, res = (loadstring or load)(data, nil, nil, env) end\n"
    "  if not f then return f, res end\n"
    "  if setfenv then setfenv(f, env) end\n"
    "  return pcall(f)\n"
    "end\n"
    "\n"
    "local function merge(a, b) if b then for k,v in pairs(b) do a[k] = v end end; return a; end\n"
    "return { _NAME = n, _COPYRIGHT = c, _DESCRIPTION = d, _VERSION = v, serialize = s,\n"
    "  load = deserialize,\n"
    "  dump = function(a, opts) return s(a, merge({name = '_', compact = true, sparse = true}, opts)) end,\n"
    "  line = function(a, opts) return s(a, merge({sortkeys = true, comment = true}, opts)) end,\n"
    "  block = function(a, opts) return s(a, merge({indent = '  ', sortkeys = true, comment = true}, opts)) end }\n"
    "end)() ---- end of Serpent module\n"
    "\n"
    "mobdebug.line = serpent.line\n"
    "mobdebug.dump = serpent.dump\n"
    "mobdebug.linemap = nil\n"
    "mobdebug.loadstring = loadstring\n"
    "\n"
    "local function removebasedir(path, basedir)\n"
    "  if iscasepreserving then\n"
    "    -- check if the lowercased path matches the basedir\n"
    "    -- if so, return substring of the original path (to not lowercase it)\n"
    "    return path:lower():find('^'..q(basedir:lower()))\n"
    "      and path:sub(#basedir+1) or path\n"
    "  else\n"
    "    return string.gsub(path, '^'..q(basedir), '')\n"
    "  end\n"
    "end\n"
    "\n"
    "local function stack(start)\n"
    "  local function vars(f)\n"
    "    local func = debug.getinfo(f, \"f\").func\n"
    "    local i = 1\n"
    "    local locals = {}\n"
    "    -- get locals\n"
    "    while true do\n"
    "      local name, value = debug.getlocal(f, i)\n"
    "      if not name then break end\n"
    "      if string.sub(name, 1, 1) ~= '(' then locals[name] = {value, tostring(value)} end\n"
    "      i = i + 1\n"
    "    end\n"
    "    -- get varargs (these use negative indices)\n"
    "    i = 1\n"
    "    while true do\n"
    "      local name, value = debug.getlocal(f, -i)\n"
    "      if not name then break end\n"
    "      locals[name:gsub(\"%)$\",\" \"..i..\")\")] = {value, tostring(value)}\n"
    "      i = i + 1\n"
    "    end\n"
    "    -- get upvalues\n"
    "    i = 1\n"
    "    local ups = {}\n"
    "    while func and true do -- check for func as it may be nil for tail calls\n"
    "      local name, value = debug.getupvalue(func, i)\n"
    "      if not name then break end\n"
    "      ups[name] = {value, tostring(value)}\n"
    "      i = i + 1\n"
    "    end\n"
    "    return locals, ups\n"
    "  end\n"
    "\n"
    "  local stack = {}\n"
    "  local linemap = mobdebug.linemap\n"
    "  for i = (start or 0), 100 do\n"
    "    local source = debug.getinfo(i, \"Snl\")\n"
    "    if not source then break end\n"
    "\n"
    "    local src = source.source\n"
    "    if src:find(\"@\") == 1 then\n"
    "      src = src:sub(2):gsub(\"\\\\\", \"/\")\n"
    "      if src:find(\"%./\") == 1 then src = src:sub(3) end\n"
    "    end\n"
    "\n"
    "    table.insert(stack, { -- remove basedir from source\n"
    "      {source.name, removebasedir(src, basedir),\n"
    "       linemap and linemap(source.linedefined, source.source) or source.linedefined,\n"
    "       linemap and linemap(source.currentline, source.source) or source.currentline,\n"
    "       source.what, source.namewhat, source.short_src},\n"
    "      vars(i+1)})\n"
    "    if source.what == 'main' then break end\n"
    "  end\n"
    "  return stack\n"
    "end\n"
    "\n"
    "local function set_breakpoint(file, line)\n"
    "  if file == '-' and lastfile then file = lastfile\n"
    "  elseif iscasepreserving then file = string.lower(file) end\n"
    "  local arr = file:split('/')\n"
    "  file = arr[table.getn(arr)]\n"
    "  if not breakpoints[line] then breakpoints[line] = {} end\n"
    "  breakpoints[line][file] = true\n"
    "  print(\"set_breakpoint file=\", file, \" line=\", line)\n"
    "end\n"
    "\n"
    "local function remove_breakpoint(file, line)\n"
    "  if file == '-' and lastfile then file = lastfile\n"
    "  elseif file == '*' and line == 0 then breakpoints = {}\n"
    "  elseif iscasepreserving then file = string.lower(file) end\n"
    "  local arr = file:split('/')\n"
    "  file = arr[table.getn(arr)]\n"
    "  if breakpoints[line] then breakpoints[line][file] = nil end\n"
    "end\n"
    "\n"
    "local function has_breakpoint(file, line)\n"
    "  local arr = file:split('/')\n"
    "  file = arr[table.getn(arr)]\n"
    "  print('has_breakpoint'..file..line)\n"
    "  return breakpoints[line]\n"
    "     and breakpoints[line][iscasepreserving and string.lower(file) or file]\n"
    "end\n"
    "\n"
    "local function restore_vars(vars)\n"
    "  if type(vars) ~= 'table' then return end\n"
    "\n"
    "  -- locals need to be processed in the reverse order, starting from\n"
    "  -- the inner block out, to make sure that the localized variables\n"
    "  -- are correctly updated with only the closest variable with\n"
    "  -- the same name being changed\n"
    "  -- first loop find how many local variables there is, while\n"
    "  -- the second loop processes them from i to 1\n"
    "  local i = 1\n"
    "  while true do\n"
    "    local name = debug.getlocal(3, i)\n"
    "    if not name then break end\n"
    "    i = i + 1\n"
    "  end\n"
    "  i = i - 1\n"
    "  local written_vars = {}\n"
    "  while i > 0 do\n"
    "    local name = debug.getlocal(3, i)\n"
    "    if not written_vars[name] then\n"
    "      if string.sub(name, 1, 1) ~= '(' then\n"
    "        debug.setlocal(3, i, rawget(vars, name))\n"
    "      end\n"
    "      written_vars[name] = true\n"
    "    end\n"
    "    i = i - 1\n"
    "  end\n"
    "\n"
    "  i = 1\n"
    "  local func = debug.getinfo(3, \"f\").func\n"
    "  while true do\n"
    "    local name = debug.getupvalue(func, i)\n"
    "    if not name then break end\n"
    "    if not written_vars[name] then\n"
    "      if string.sub(name, 1, 1) ~= '(' then\n"
    "        debug.setupvalue(func, i, rawget(vars, name))\n"
    "      end\n"
    "      written_vars[name] = true\n"
    "    end\n"
    "    i = i + 1\n"
    "  end\n"
    "end\n"
    "\n"
    "local function capture_vars(level)\n"
    "  local vars = {}\n"
    "  local func = debug.getinfo(level or 3, \"f\").func\n"
    "  local i = 1\n"
    "  while true do\n"
    "    local name, value = debug.getupvalue(func, i)\n"
    "    if not name then break end\n"
    "    if string.sub(name, 1, 1) ~= '(' then vars[name] = value end\n"
    "    i = i + 1\n"
    "  end\n"
    "  i = 1\n"
    "  while true do\n"
    "    local name, value = debug.getlocal(level or 3, i)\n"
    "    if not name then break end\n"
    "    if string.sub(name, 1, 1) ~= '(' then vars[name] = value end\n"
    "    i = i + 1\n"
    "  end\n"
    "  -- returned 'vars' table plays a dual role: (1) it captures local values\n"
    "  -- and upvalues to be restored later (in case they are modified in \"eval\"),\n"
    "  -- and (2) it provides an environment for evaluated chunks.\n"
    "  -- getfenv(func) is needed to provide proper environment for functions,\n"
    "  -- including access to globals, but this causes vars[name] to fail in\n"
    "  -- restore_vars on local variables or upvalues with `nil` values when\n"
    "  -- 'strict' is in effect. To avoid this `rawget` is used in restore_vars.\n"
    "  setmetatable(vars, { __index = getfenv(func), __newindex = getfenv(func) })\n"
    "  return vars\n"
    "end\n"
    "\n"
    "local function stack_depth(start_depth)\n"
    "  for i = start_depth, 0, -1 do\n"
    "    if debug.getinfo(i, \"l\") then return i+1 end\n"
    "  end\n"
    "  return start_depth\n"
    "end\n"
    "\n"
    "local function is_safe(stack_level)\n"
    "  -- the stack grows up: 0 is getinfo, 1 is is_safe, 2 is debug_hook, 3 is user function\n"
    "  if stack_level == 3 then return true end\n"
    "  for i = 3, stack_level do\n"
    "    -- return if it is not safe to abort\n"
    "    local info = debug.getinfo(i, \"S\")\n"
    "    if not info then return true end\n"
    "    if info.what == \"C\" then return false end\n"
    "  end\n"
    "  return true\n"
    "end\n"
    "\n"
    "local function in_debugger()\n"
    "  local this = debug.getinfo(1, \"S\").source\n"
    "  -- only need to check few frames as mobdebug frames should be close\n"
    "  for i = 3, 7 do\n"
    "    local info = debug.getinfo(i, \"S\")\n"
    "    if not info then return false end\n"
    "    if info.source == this then return true end\n"
    "  end\n"
    "  return false\n"
    "end\n"
    "\n"
    "local function is_pending(peer)\n"
    "  -- if there is something already in the buffer, skip check\n"
    "  if not buf and checkcount >= mobdebug.checkcount then\n"
    "    peer:settimeout(0) -- non-blocking\n"
    "    buf = peer:receive(1)\n"
    "    peer:settimeout() -- back to blocking\n"
    "    checkcount = 0\n"
    "  end\n"
    "  return buf\n"
    "end\n"
    "\n"
    "local function readnext(peer, num)\n"
    "  peer:settimeout(0) -- non-blocking\n"
    "  local res, err, partial = peer:receive(num)\n"
    "  peer:settimeout() -- back to blocking\n"
    "  return res or partial or '', err\n"
    "end\n"
    "\n"
    "local function handle_breakpoint(peer)\n"
    "  -- check if the buffer has the beginning of SETB/DELB command;\n"
    "  -- this is to avoid reading the entire line for commands that\n"
    "  -- don't need to be handled here.\n"
    "  if not buf or not (buf:sub(1,1) == 'S' or buf:sub(1,1) == 'D') then return end\n"
    "\n"
    "  -- check second character to avoid reading STEP or other S* and D* commands\n"
    "  if #buf == 1 then buf = buf .. readnext(peer, 1) end\n"
    "  if buf:sub(2,2) ~= 'E' then return end\n"
    "\n"
    "  -- need to read few more characters\n"
    "  buf = buf .. readnext(peer, 5-#buf)\n"
    "  if buf ~= 'SETB ' and buf ~= 'DELB ' then return end\n"
    "\n"
    "  local res, _, partial = peer:receive() -- get the rest of the line; blocking\n"
    "  if not res then\n"
    "    if partial then buf = buf .. partial end\n"
    "    return\n"
    "  end\n"
    "\n"
    "  local _, _, cmd, file, line = (buf..res):find(\"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\n"
    "  if cmd == 'SETB' then set_breakpoint(file, tonumber(line))\n"
    "  elseif cmd == 'DELB' then remove_breakpoint(file, tonumber(line))\n"
    "  else\n"
    "    -- this looks like a breakpoint command, but something went wrong;\n"
    "    -- return here to let the \"normal\" processing to handle,\n"
    "    -- although this is likely to not go well.\n"
    "    return\n"
    "  end\n"
    "\n"
    "  buf = nil\n"
    "end\n"
    "\n"
    "local function debug_hook(event, line)\n"
    "  -- print(\"debug_hook event=\", event, \" line=\", line);\n"
    "  -- (1) LuaJIT needs special treatment. Because debug_hook is set for\n"
    "  -- *all* coroutines, and not just the one being debugged as in regular Lua\n"
    "  -- (http://lua-users.org/lists/lua-l/2011-06/msg00513.html),\n"
    "  -- need to avoid debugging mobdebug's own code as LuaJIT doesn't\n"
    "  -- always correctly generate call/return hook events (there are more\n"
    "  -- calls than returns, which breaks stack depth calculation and\n"
    "  -- 'step' and 'step over' commands stop working; possibly because\n"
    "  -- 'tail return' events are not generated by LuaJIT).\n"
    "  -- the next line checks if the debugger is run under LuaJIT and if\n"
    "  -- one of debugger methods is present in the stack, it simply returns.\n"
    "  if jit then\n"
    "    -- when luajit is compiled with LUAJIT_ENABLE_LUA52COMPAT,\n"
    "    -- coroutine.running() returns non-nil for the main thread.\n"
    "    local coro, main = coroutine.running()\n"
    "    if not coro or main then coro = 'main' end\n"
    "    local disabled = coroutines[coro] == false\n"
    "      or coroutines[coro] == nil and coro ~= (coro_debugee or 'main')\n"
    "    if coro_debugee and disabled or not coro_debugee and (disabled or in_debugger())\n"
    "    then return end\n"
    "  end\n"
    "\n"
    "  -- (2) check if abort has been requested and it's safe to abort\n"
    "  if abort and is_safe(stack_level) then error(abort) end\n"
    "\n"
    "  -- (3) also check if this debug hook has not been visited for any reason.\n"
    "  -- this check is needed to avoid stepping in too early\n"
    "  -- (for example, when coroutine.resume() is executed inside start()).\n"
    "  if not seen_hook and in_debugger() then return end\n"
    "\n"
    "  if event == \"call\" then\n"
    "    stack_level = stack_level + 1\n"
    "  elseif event == \"return\" or event == \"tail return\" then\n"
    "    stack_level = stack_level - 1\n"
    "  elseif event == \"line\" then\n"
    "    if mobdebug.linemap then\n"
    "      local ok, mappedline = pcall(mobdebug.linemap, line, debug.getinfo(2, \"S\").source)\n"
    "      if ok then line = mappedline end\n"
    "      if not line then return end\n"
    "    end\n"
    "\n"
    "    -- may need to fall through because of the following:\n"
    "    -- (1) step_into\n"
    "    -- (2) step_over and stack_level <= step_level (need stack_level)\n"
    "    -- (3) breakpoint; check for line first as it's known; then for file\n"
    "    -- (4) socket call (only do every Xth check)\n"
    "    -- (5) at least one watch is registered\n"
    "    if not (\n"
    "      step_into or step_over or breakpoints[line] or watchescnt > 0\n"
    "      or is_pending(server)\n"
    "    ) then checkcount = checkcount + 1; return end\n"
    "\n"
    "    checkcount = mobdebug.checkcount -- force check on the next command\n"
    "\n"
    "    -- this is needed to check if the stack got shorter or longer.\n"
    "    -- unfortunately counting call/return calls is not reliable.\n"
    "    -- the discrepancy may happen when \"pcall(load, '')\" call is made\n"
    "    -- or when \"error()\" is called in a function.\n"
    "    -- in either case there are more \"call\" than \"return\" events reported.\n"
    "    -- this validation is done for every \"line\" event, but should be \"cheap\"\n"
    "    -- as it checks for the stack to get shorter (or longer by one call).\n"
    "    -- start from one level higher just in case we need to grow the stack.\n"
    "    -- this may happen after coroutine.resume call to a function that doesn't\n"
    "    -- have any other instructions to execute. it triggers three returns:\n"
    "    -- \"return, tail return, return\", which needs to be accounted for.\n"
    "    stack_level = stack_depth(stack_level+1)\n"
    "\n"
    "    local caller = debug.getinfo(2, \"S\")\n"
    "\n"
    "    -- grab the filename and fix it if needed\n"
    "    local file = lastfile\n"
    "    if (lastsource ~= caller.source) then\n"
    "      file, lastsource = caller.source, caller.source\n"
    "      -- technically, users can supply names that may not use '@',\n"
    "      -- for example when they call loadstring('...', 'filename.lua').\n"
    "      -- Unfortunately, there is no reliable/quick way to figure out\n"
    "      -- what is the filename and what is the source code.\n"
    "      -- The following will work if the supplied filename uses Unix path.\n"
    "      if find(file, \"^@\") then\n"
    "        file = gsub(gsub(file, \"^@\", \"\"), \"\\\\\", \"/\")\n"
    "        -- need this conversion to be applied to relative and absolute\n"
    "        -- file names as you may write \"require 'Foo'\" to\n"
    "        -- load \"foo.lua\" (on a case insensitive file system) and breakpoints\n"
    "        -- set on foo.lua will not work if not converted to the same case.\n"
    "        if iscasepreserving then file = string.lower(file) end\n"
    "        if find(file, \"%./\") == 1 then file = sub(file, 3)\n"
    "        else file = gsub(file, \"^\"..q(basedir), \"\") end\n"
    "        -- some file systems allow newlines in file names; remove these.\n"
    "        file = gsub(file, \"\\n\", ' ')\n"
    "      else\n"
    "        -- this is either a file name coming from loadstring(\"chunk\", \"file\"),\n"
    "        -- or the actual source code that needs to be serialized (as it may\n"
    "        -- include newlines); assume it's a file name if it's all on one line.\n"
    "        if find(file, \"[\\r\\n]\") then\n"
    "          file = mobdebug.line(file)\n"
    "        else\n"
    "          if iscasepreserving then file = string.lower(file) end\n"
    "          file = gsub(gsub(file, \"\\\\\", \"/\"), find(file, \"^%./\") and \"^%./\" or \"^\"..q(basedir), \"\")\n"
    "        end\n"
    "      end\n"
    "\n"
    "      -- set to true if we got here; this only needs to be done once per\n"
    "      -- session, so do it here to at least avoid setting it for every line.\n"
    "      seen_hook = true\n"
    "      lastfile = file\n"
    "    end\n"
    "\n"
    "    if is_pending(server) then handle_breakpoint(server) end\n"
    "\n"
    "    local vars, status, res\n"
    "    if (watchescnt > 0) then\n"
    "      vars = capture_vars()\n"
    "      for index, value in pairs(watches) do\n"
    "        setfenv(value, vars)\n"
    "        local ok, fired = pcall(value)\n"
    "        if ok and fired then\n"
    "          status, res = cororesume(coro_debugger, events.WATCH, vars, file, line, index)\n"
    "          break -- any one watch is enough; don't check multiple times\n"
    "        end\n"
    "      end\n"
    "    end\n"
    "\n"
    "    -- need to get into the \"regular\" debug handler, but only if there was\n"
    "    -- no watch that was fired. If there was a watch, handle its result.\n"
    "    local getin = (status == nil) and\n"
    "      (step_into\n"
    "      -- when coroutine.running() return `nil` (main thread in Lua 5.1),\n"
    "      -- step_over will equal 'main', so need to check for that explicitly.\n"
    "      or (step_over and step_over == (coroutine.running() or 'main') and stack_level <= step_level)\n"
    "      or has_breakpoint(file, line)\n"
    "      or is_pending(server))\n"
    "\n"
    "    if getin then\n"
    "      vars = vars or capture_vars()\n"
    "      step_into = false\n"
    "      step_over = false\n"
    "      status, res = cororesume(coro_debugger, events.BREAK, vars, file, line)\n"
    "    end\n"
    "\n"
    "    -- handle 'stack' command that provides stack() information to the debugger\n"
    "    if status and res == 'stack' then\n"
    "      while status and res == 'stack' do\n"
    "        -- resume with the stack trace and variables\n"
    "        if vars then restore_vars(vars) end -- restore vars so they are reflected in stack values\n"
    "        -- this may fail if __tostring method fails at run-time\n"
    "        local ok, snapshot = pcall(stack, ngx and 5 or 4)\n"
    "        status, res = cororesume(coro_debugger, ok and events.STACK or events.BREAK, snapshot, file, line)\n"
    "      end\n"
    "    end\n"
    "\n"
    "    -- need to recheck once more as resume after 'stack' command may\n"
    "    -- return something else (for example, 'exit'), which needs to be handled\n"
    "    if status and res and res ~= 'stack' then\n"
    "      if not abort and res == \"exit\" then mobdebug.onexit(1, true); return end\n"
    "      if not abort and res == \"done\" then mobdebug.done(); return end\n"
    "      abort = res\n"
    "      -- only abort if safe; if not, there is another (earlier) check inside\n"
    "      -- debug_hook, which will abort execution at the first safe opportunity\n"
    "      if is_safe(stack_level) then error(abort) end\n"
    "    elseif not status and res then\n"
    "      error(res, 2) -- report any other (internal) errors back to the application\n"
    "    end\n"
    "\n"
    "    if vars then restore_vars(vars) end\n"
    "\n"
    "    -- last command requested Step Over/Out; store the current thread\n"
    "    if step_over == true then step_over = coroutine.running() or 'main' end\n"
    "  end\n"
    "end\n"
    "\n"
    "local function stringify_results(status, ...)\n"
    "  if not status then return status, ... end -- on error report as it\n"
    "\n"
    "  local t = {...}\n"
    "  for i,v in pairs(t) do -- stringify each of the returned values\n"
    "    local ok, res = pcall(mobdebug.line, v, {nocode = true, comment = 1})\n"
    "    t[i] = ok and res or (\"%q\"):format(res):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\")\n"
    "  end\n"
    "  -- stringify table with all returned values\n"
    "  -- this is done to allow each returned value to be used (serialized or not)\n"
    "  -- intependently and to preserve \"original\" comments\n"
    "  return pcall(mobdebug.dump, t, {sparse = false})\n"
    "end\n"
    "\n"
    "local function isrunning()\n"
    "  return coro_debugger and (corostatus(coro_debugger) == 'suspended' or corostatus(coro_debugger) == 'running')\n"
    "end\n"
    "\n"
    "-- this is a function that removes all hooks and closes the socket to\n"
    "-- report back to the controller that the debugging is done.\n"
    "-- the script that called `done` can still continue.\n"
    "local function done()\n"
    "  if not (isrunning() and server) then return end\n"
    "\n"
    "  if not jit then\n"
    "    for co, debugged in pairs(coroutines) do\n"
    "      if debugged then debug.sethook(co) end\n"
    "    end\n"
    "  end\n"
    "\n"
    "  debug.sethook()\n"
    "  server:close()\n"
    "\n"
    "  coro_debugger = nil -- to make sure isrunning() returns `false`\n"
    "  seen_hook = nil -- to make sure that the next start() call works\n"
    "  abort = nil -- to make sure that callback calls use proper \"abort\" value\n"
    "end\n"
    "\n"
    "local function debugger_loop(sev, svars, sfile, sline)\n"
    "  local command\n"
    "  local app, osname\n"
    "  local eval_env = svars or {}\n"
    "  local function emptyWatch () return false end\n"
    "  local loaded = {}\n"
    "  for k in pairs(package.loaded) do loaded[k] = true end\n"
    "\n"
    "  while true do\n"
    "    local line, err\n"
    "    local wx = rawget(genv, \"wx\") -- use rawread to make strict.lua happy\n"
    "    if (wx or mobdebug.yield) and server.settimeout then server:settimeout(mobdebug.yieldtimeout) end\n"
    "    while true do\n"
    "      line, err = server:receive()\n"
    "      if not line and err == \"timeout\" then\n"
    "        -- yield for wx GUI applications if possible to avoid \"busyness\"\n"
    "        app = app or (wx and wx.wxGetApp and wx.wxGetApp())\n"
    "        if app then\n"
    "          local win = app:GetTopWindow()\n"
    "          local inloop = app:IsMainLoopRunning()\n"
    "          osname = osname or wx.wxPlatformInfo.Get():GetOperatingSystemFamilyName()\n"
    "          if win and not inloop then\n"
    "            -- process messages in a regular way\n"
    "            -- and exit as soon as the event loop is idle\n"
    "            if osname == 'Unix' then wx.wxTimer(app):Start(10, true) end\n"
    "            local exitLoop = function()\n"
    "              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)\n"
    "              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)\n"
    "              app:ExitMainLoop()\n"
    "            end\n"
    "            win:Connect(wx.wxEVT_IDLE, exitLoop)\n"
    "            win:Connect(wx.wxEVT_TIMER, exitLoop)\n"
    "            app:MainLoop()\n"
    "          end\n"
    "        elseif mobdebug.yield then mobdebug.yield()\n"
    "        end\n"
    "      elseif not line and err == \"closed\" then\n"
    "        error(\"Debugger connection closed\", 0)\n"
    "      else\n"
    "        -- if there is something in the pending buffer, prepend it to the line\n"
    "        if buf then line = buf .. line; buf = nil end\n"
    "        break\n"
    "      end\n"
    "    end\n"
    "    if server.settimeout then server:settimeout() end -- back to blocking\n"
    "    command = string.sub(line, string.find(line, \"^[A-Z]+\"))\n"
    "    if command == \"SETB\" then\n"
    "      local _, _, _, file, line = string.find(line, \"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\n"
    "      if file and line then\n"
    "        set_breakpoint(file, tonumber(line))\n"
    "        server:send(\"200 OK\\n\")\n"
    "      else\n"
    "        server:send(\"400 Bad Request\\n\")\n"
    "      end\n"
    "    elseif command == \"DELB\" then\n"
    "      local _, _, _, file, line = string.find(line, \"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\n"
    "      if file and line then\n"
    "        remove_breakpoint(file, tonumber(line))\n"
    "        server:send(\"200 OK\\n\")\n"
    "      else\n"
    "        server:send(\"400 Bad Request\\n\")\n"
    "      end\n"
    "    elseif command == \"EXEC\" then\n"
    "      local _, _, chunk = string.find(line, \"^[A-Z]+%s+(.+)$\")\n"
    "      if chunk then\n"
    "        local func, res = mobdebug.loadstring(chunk)\n"
    "        local status\n"
    "        if func then\n"
    "          setfenv(func, eval_env)\n"
    "          status, res = stringify_results(pcall(func))\n"
    "        end\n"
    "        if status then\n"
    "          server:send(\"200 OK \" .. tostring(#res) .. \"\\n\")\n"
    "          server:send(res)\n"
    "        else\n"
    "          -- fix error if not set (for example, when loadstring is not present)\n"
    "          if not res then res = \"Unknown error\" end\n"
    "          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\n"
    "          server:send(res)\n"
    "        end\n"
    "      else\n"
    "        server:send(\"400 Bad Request\\n\")\n"
    "      end\n"
    "    elseif command == \"LOAD\" then\n"
    "      local _, _, size, name = string.find(line, \"^[A-Z]+%s+(%d+)%s+(%S.-)%s*$\")\n"
    "      size = tonumber(size)\n"
    "\n"
    "      if abort == nil then -- no LOAD/RELOAD allowed inside start()\n"
    "        if size > 0 then server:receive(size) end\n"
    "        if sfile and sline then\n"
    "          server:send(\"201 Started \" .. sfile .. \" \" .. tostring(sline) .. \"\\n\")\n"
    "        else\n"
    "          server:send(\"200 OK 0\\n\")\n"
    "        end\n"
    "      else\n"
    "        -- reset environment to allow required modules to load again\n"
    "        -- remove those packages that weren't loaded when debugger started\n"
    "        for k in pairs(package.loaded) do\n"
    "          if not loaded[k] then package.loaded[k] = nil end\n"
    "        end\n"
    "\n"
    "        if size == 0 and name == '-' then -- RELOAD the current script being debugged\n"
    "          server:send(\"200 OK 0\\n\")\n"
    "          coroyield(\"load\")\n"
    "        else\n"
    "          -- receiving 0 bytes blocks (at least in luasocket 2.0.2), so skip reading\n"
    "          local chunk = size == 0 and \"\" or server:receive(size)\n"
    "          if chunk then -- LOAD a new script for debugging\n"
    "            local func, res = mobdebug.loadstring(chunk, \"@\"..name)\n"
    "            if func then\n"
    "              server:send(\"200 OK 0\\n\")\n"
    "              debugee = func\n"
    "              coroyield(\"load\")\n"
    "            else\n"
    "              server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\n"
    "              server:send(res)\n"
    "            end\n"
    "          else\n"
    "            server:send(\"400 Bad Request\\n\")\n"
    "          end\n"
    "        end\n"
    "      end\n"
    "    elseif command == \"SETW\" then\n"
    "      local _, _, exp = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")\n"
    "      if exp then\n"
    "        local func, res = mobdebug.loadstring(\"return(\" .. exp .. \")\")\n"
    "        if func then\n"
    "          watchescnt = watchescnt + 1\n"
    "          local newidx = #watches + 1\n"
    "          watches[newidx] = func\n"
    "          server:send(\"200 OK \" .. tostring(newidx) .. \"\\n\")\n"
    "        else\n"
    "          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\n"
    "          server:send(res)\n"
    "        end\n"
    "      else\n"
    "        server:send(\"400 Bad Request\\n\")\n"
    "      end\n"
    "    elseif command == \"DELW\" then\n"
    "      local _, _, index = string.find(line, \"^[A-Z]+%s+(%d+)%s*$\")\n"
    "      index = tonumber(index)\n"
    "      if index > 0 and index <= #watches then\n"
    "        watchescnt = watchescnt - (watches[index] ~= emptyWatch and 1 or 0)\n"
    "        watches[index] = emptyWatch\n"
    "        server:send(\"200 OK\\n\")\n"
    "      else\n"
    "        server:send(\"400 Bad Request\\n\")\n"
    "      end\n"
    "    elseif command == \"RUN\" then\n"
    "      server:send(\"200 OK\\n\")\n"
    "\n"
    "      local ev, vars, file, line, idx_watch = coroyield()\n"
    "      eval_env = vars\n"
    "      if ev == events.BREAK then\n"
    "        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\n"
    "      elseif ev == events.WATCH then\n"
    "        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\n"
    "      elseif ev == events.RESTART then\n"
    "        -- nothing to do\n"
    "      else\n"
    "        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\n"
    "        server:send(file)\n"
    "      end\n"
    "    elseif command == \"STEP\" then\n"
    "      server:send(\"200 OK\\n\")\n"
    "      step_into = true\n"
    "\n"
    "      local ev, vars, file, line, idx_watch = coroyield()\n"
    "      eval_env = vars\n"
    "      if ev == events.BREAK then\n"
    "        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\n"
    "      elseif ev == events.WATCH then\n"
    "        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\n"
    "      elseif ev == events.RESTART then\n"
    "        -- nothing to do\n"
    "      else\n"
    "        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\n"
    "        server:send(file)\n"
    "      end\n"
    "    elseif command == \"OVER\" or command == \"OUT\" then\n"
    "      server:send(\"200 OK\\n\")\n"
    "      step_over = true\n"
    "\n"
    "      -- OVER and OUT are very similar except for\n"
    "      -- the stack level value at which to stop\n"
    "      if command == \"OUT\" then step_level = stack_level - 1\n"
    "      else step_level = stack_level end\n"
    "\n"
    "      local ev, vars, file, line, idx_watch = coroyield()\n"
    "      eval_env = vars\n"
    "      if ev == events.BREAK then\n"
    "        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\n"
    "      elseif ev == events.WATCH then\n"
    "        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\n"
    "      elseif ev == events.RESTART then\n"
    "        -- nothing to do\n"
    "      else\n"
    "        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\n"
    "        server:send(file)\n"
    "      end\n"
    "    elseif command == \"BASEDIR\" then\n"
    "      local _, _, dir = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")\n"
    "      if dir then\n"
    "        basedir = iscasepreserving and string.lower(dir) or dir\n"
    "        -- reset cached source as it may change with basedir\n"
    "        lastsource = nil\n"
    "        server:send(\"200 OK\\n\")\n"
    "      else\n"
    "        server:send(\"400 Bad Request\\n\")\n"
    "      end\n"
    "    elseif command == \"SUSPEND\" then\n"
    "      -- do nothing; it already fulfilled its role\n"
    "    elseif command == \"DONE\" then\n"
    "      coroyield(\"done\")\n"
    "      return -- done with all the debugging\n"
    "    elseif command == \"STACK\" then\n"
    "      -- first check if we can execute the stack command\n"
    "      -- as it requires yielding back to debug_hook it cannot be executed\n"
    "      -- if we have not seen the hook yet as happens after start().\n"
    "      -- in this case we simply return an empty result\n"
    "      local vars, ev = {}\n"
    "      if seen_hook then\n"
    "        ev, vars = coroyield(\"stack\")\n"
    "      end\n"
    "      if ev and ev ~= events.STACK then\n"
    "        server:send(\"401 Error in Execution \" .. tostring(#vars) .. \"\\n\")\n"
    "        server:send(vars)\n"
    "      else\n"
    "        local ok, res = pcall(mobdebug.dump, vars, {nocode = true, sparse = false})\n"
    "        if ok then\n"
    "          server:send(\"200 OK \" .. tostring(res) .. \"\\n\")\n"
    "        else\n"
    "          server:send(\"401 Error in Execution \" .. tostring(#res) .. \"\\n\")\n"
    "          server:send(res)\n"
    "        end\n"
    "      end\n"
    "    elseif command == \"OUTPUT\" then\n"
    "      local _, _, stream, mode = string.find(line, \"^[A-Z]+%s+(%w+)%s+([dcr])%s*$\")\n"
    "      if stream and mode and stream == \"stdout\" then\n"
    "        -- assign \"print\" in the global environment\n"
    "        local default = mode == 'd'\n"
    "        genv.print = default and iobase.print or corowrap(function()\n"
    "          -- wrapping into coroutine.wrap protects this function from\n"
    "          -- being stepped through in the debugger.\n"
    "          -- don't use vararg (...) as it adds a reference for its values,\n"
    "          -- which may affect how they are garbage collected\n"
    "          while true do\n"
    "            local tbl = {coroutine.yield()}\n"
    "            if mode == 'c' then iobase.print(unpack(tbl)) end\n"
    "            for n = 1, #tbl do\n"
    "              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end\n"
    "            local file = table.concat(tbl, \"\\t\")..\"\\n\"\n"
    "            server:send(\"204 Output \" .. stream .. \" \" .. tostring(#file) .. \"\\n\" .. file)\n"
    "          end\n"
    "        end)\n"
    "        if not default then genv.print() end -- \"fake\" print to start printing loop\n"
    "        server:send(\"200 OK\\n\")\n"
    "      else\n"
    "        server:send(\"400 Bad Request\\n\")\n"
    "      end\n"
    "    elseif command == \"EXIT\" then\n"
    "      server:send(\"200 OK\\n\")\n"
    "      coroyield(\"exit\")\n"
    "    else\n"
    "      server:send(\"400 Bad Request\\n\")\n"
    "    end\n"
    "  end\n"
    "end\n"
    "\n"
    "local function connect(controller_host, controller_port)\n"
    "  local sock, err = socket.tcp()\n"
    "  if not sock then return nil, err end\n"
    "\n"
    "  if sock.settimeout then sock:settimeout(mobdebug.connecttimeout) end\n"
    "  local res, err = sock:connect(controller_host, tostring(controller_port))\n"
    "  if sock.settimeout then sock:settimeout() end\n"
    "\n"
    "  if not res then return nil, err end\n"
    "  return sock\n"
    "end\n"
    "\n"
    "local lasthost, lastport\n"
    "\n"
    "-- Starts a debug session by connecting to a controller\n"
    "local function start(controller_host, controller_port)\n"
    "  -- only one debugging session can be run (as there is only one debug hook)\n"
    "  print(\"start 998\")\n"
    "  if isrunning() then return end\n"
    "  print(\"start 1000\")\n"
    "  lasthost = controller_host or lasthost\n"
    "  lastport = controller_port or lastport\n"
    "\n"
    "  controller_host = lasthost or \"localhost\"\n"
    "  controller_port = lastport or mobdebug.port\n"
    "\n"
    "  local err\n"
    "  server, err = mobdebug.connect(controller_host, controller_port)\n"
    "  if server then\n"
    "    print(\"server connect success\")\n"
    "    -- correct stack depth which already has some calls on it\n"
    "    -- so it doesn't go into negative when those calls return\n"
    "    -- as this breaks subsequence checks in stack_depth().\n"
    "    -- start from 16th frame, which is sufficiently large for this check.\n"
    "    stack_level = stack_depth(16)\n"
    "\n"
    "    -- provide our own traceback function to report the error remotely\n"
    "    do\n"
    "      local dtraceback = debug.traceback\n"
    "      debug.traceback = function (...)\n"
    "        if select('#', ...) >= 1 then\n"
    "          local err, lvl = ...\n"
    "          if err and type(err) ~= 'thread' then\n"
    "            local trace = dtraceback(err, (lvl or 2)+1)\n"
    "            if genv.print == iobase.print then -- no remote redirect\n"
    "              return trace\n"
    "            else\n"
    "              genv.print(trace) -- report the error remotely\n"
    "              return -- don't report locally to avoid double reporting\n"
    "            end\n"
    "          end\n"
    "        end\n"
    "        -- direct call to debug.traceback: return the original.\n"
    "        -- debug.traceback(nil, level) doesn't work in Lua 5.1\n"
    "        -- (http://lua-users.org/lists/lua-l/2011-06/msg00574.html), so\n"
    "        -- simply remove first frame from the stack trace\n"
    "        return (dtraceback(...):gsub(\"(stack traceback:\\n)[^\\n]*\\n\", \"%1\"))\n"
    "      end\n"
    "    end\n"
    "    coro_debugger = corocreate(debugger_loop)\n"
    "    debug.sethook(debug_hook, \"lcr\")\n"
    "    seen_hook = nil -- reset in case the last start() call was refused\n"
    "    step_into = true -- start with step command\n"
    "    return true\n"
    "  else\n"
    "    print((\"Could not connect to %s:%s: %s\")\n"
    "      :format(controller_host, controller_port, err or \"unknown error\"))\n"
    "  end\n"
    "end\n"
    "\n"
    "local function controller(controller_host, controller_port, scratchpad)\n"
    "  -- only one debugging session can be run (as there is only one debug hook)\n"
    "  if isrunning() then return end\n"
    "\n"
    "  lasthost = controller_host or lasthost\n"
    "  lastport = controller_port or lastport\n"
    "\n"
    "  controller_host = lasthost or \"localhost\"\n"
    "  controller_port = lastport or mobdebug.port\n"
    "\n"
    "  local exitonerror = not scratchpad\n"
    "  local err\n"
    "  server, err = mobdebug.connect(controller_host, controller_port)\n"
    "  if server then\n"
    "    local function report(trace, err)\n"
    "      local msg = err .. \"\\n\" .. trace\n"
    "      server:send(\"401 Error in Execution \" .. tostring(#msg) .. \"\\n\")\n"
    "      server:send(msg)\n"
    "      return err\n"
    "    end\n"
    "\n"
    "    seen_hook = true -- allow to accept all commands\n"
    "    coro_debugger = corocreate(debugger_loop)\n"
    "\n"
    "    while true do\n"
    "      step_into = true -- start with step command\n"
    "      abort = false -- reset abort flag from the previous loop\n"
    "      if scratchpad then checkcount = mobdebug.checkcount end -- force suspend right away\n"
    "\n"
    "      coro_debugee = corocreate(debugee)\n"
    "      debug.sethook(coro_debugee, debug_hook, \"lcr\")\n"
    "      local status, err = cororesume(coro_debugee)\n"
    "\n"
    "      -- was there an error or is the script done?\n"
    "      -- 'abort' state is allowed here; ignore it\n"
    "      if abort then\n"
    "        if tostring(abort) == 'exit' then break end\n"
    "      else\n"
    "        if status then -- normal execution is done\n"
    "          break\n"
    "        elseif err and not string.find(tostring(err), deferror) then\n"
    "          -- report the error back\n"
    "          -- err is not necessarily a string, so convert to string to report\n"
    "          report(debug.traceback(coro_debugee), tostring(err))\n"
    "          if exitonerror then break end\n"
    "          -- check if the debugging is done (coro_debugger is nil)\n"
    "          if not coro_debugger then break end\n"
    "          -- resume once more to clear the response the debugger wants to send\n"
    "          -- need to use capture_vars(2) as three would be the level of\n"
    "          -- the caller for controller(), but because of the tail call,\n"
    "          -- the caller may not exist;\n"
    "          -- This is not entirely safe as the user may see the local\n"
    "          -- variable from console, but they will be reset anyway.\n"
    "          -- This functionality is used when scratchpad is paused to\n"
    "          -- gain access to remote console to modify global variables.\n"
    "          local status, err = cororesume(coro_debugger, events.RESTART, capture_vars(2))\n"
    "          if not status or status and err == \"exit\" then break end\n"
    "        end\n"
    "      end\n"
    "    end\n"
    "  else\n"
    "    print((\"Could not connect to %s:%s: %s\")\n"
    "      :format(controller_host, controller_port, err or \"unknown error\"))\n"
    "    return false\n"
    "  end\n"
    "  return true\n"
    "end\n"
    "\n"
    "local function scratchpad(controller_host, controller_port)\n"
    "  return controller(controller_host, controller_port, true)\n"
    "end\n"
    "\n"
    "local function loop(controller_host, controller_port)\n"
    "  return controller(controller_host, controller_port, false)\n"
    "end\n"
    "\n"
    "local function on()\n"
    "  if not (isrunning() and server) then return end\n"
    "\n"
    "  -- main is set to true under Lua5.2 for the \"main\" chunk.\n"
    "  -- Lua5.1 returns co as `nil` in that case.\n"
    "  local co, main = coroutine.running()\n"
    "  if main then co = nil end\n"
    "  if co then\n"
    "    coroutines[co] = true\n"
    "    debug.sethook(co, debug_hook, \"lcr\")\n"
    "  else\n"
    "    if jit then coroutines.main = true end\n"
    "    debug.sethook(debug_hook, \"lcr\")\n"
    "  end\n"
    "end\n"
    "\n"
    "local function off()\n"
    "  if not (isrunning() and server) then return end\n"
    "\n"
    "  -- main is set to true under Lua5.2 for the \"main\" chunk.\n"
    "  -- Lua5.1 returns co as `nil` in that case.\n"
    "  local co, main = coroutine.running()\n"
    "  if main then co = nil end\n"
    "\n"
    "  -- don't remove coroutine hook under LuaJIT as there is only one (global) hook\n"
    "  if co then\n"
    "    coroutines[co] = false\n"
    "    if not jit then debug.sethook(co) end\n"
    "  else\n"
    "    if jit then coroutines.main = false end\n"
    "    if not jit then debug.sethook() end\n"
    "  end\n"
    "\n"
    "  -- check if there is any thread that is still being debugged under LuaJIT;\n"
    "  -- if not, turn the debugging off\n"
    "  if jit then\n"
    "    local remove = true\n"
    "    for _, debugged in pairs(coroutines) do\n"
    "      if debugged then remove = false; break end\n"
    "    end\n"
    "    if remove then debug.sethook() end\n"
    "  end\n"
    "end\n"
    "\n"
    "-- Handles server debugging commands\n"
    "local function handle(params, client, options)\n"
    "  local _, _, command = string.find(params, \"^([a-z]+)\")\n"
    "  local file, line, watch_idx\n"
    "  if command == \"run\" or command == \"step\" or command == \"out\"\n"
    "  or command == \"over\" or command == \"exit\" then\n"
    "    client:send(string.upper(command) .. \"\\n\")\n"
    "    client:receive() -- this should consume the first '200 OK' response\n"
    "    while true do\n"
    "      local done = true\n"
    "      local breakpoint = client:receive()\n"
    "      if not breakpoint then\n"
    "        print(\"Program finished\")\n"
    "        return\n"
    "      end\n"
    "      local _, _, status = string.find(breakpoint, \"^(%d+)\")\n"
    "      if status == \"200\" then\n"
    "        -- don't need to do anything\n"
    "      elseif status == \"202\" then\n"
    "        _, _, file, line = string.find(breakpoint, \"^202 Paused%s+(.-)%s+(%d+)%s*$\")\n"
    "        if file and line then\n"
    "          print(\"Paused at file \" .. file .. \" line \" .. line)\n"
    "        end\n"
    "      elseif status == \"203\" then\n"
    "        _, _, file, line, watch_idx = string.find(breakpoint, \"^203 Paused%s+(.-)%s+(%d+)%s+(%d+)%s*$\")\n"
    "        if file and line and watch_idx then\n"
    "          print(\"Paused at file \" .. file .. \" line \" .. line .. \" (watch expression \" .. watch_idx .. \": [\" .. watches[watch_idx] .. \"])\")\n"
    "        end\n"
    "      elseif status == \"204\" then\n"
    "        local _, _, stream, size = string.find(breakpoint, \"^204 Output (%w+) (%d+)$\")\n"
    "        if stream and size then\n"
    "          local msg = client:receive(tonumber(size))\n"
    "          print(msg)\n"
    "          if outputs[stream] then outputs[stream](msg) end\n"
    "          -- this was just the output, so go back reading the response\n"
    "          done = false\n"
    "        end\n"
    "      elseif status == \"401\" then\n"
    "        local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)$\")\n"
    "        if size then\n"
    "          local msg = client:receive(tonumber(size))\n"
    "          print(\"Error in remote application: \" .. msg)\n"
    "          return nil, nil, msg\n"
    "        end\n"
    "      else\n"
    "        print(\"Unknown error\")\n"
    "        return nil, nil, \"Debugger error: unexpected response '\" .. breakpoint .. \"'\"\n"
    "      end\n"
    "      if done then break end\n"
    "    end\n"
    "  elseif command == \"done\" then\n"
    "    client:send(string.upper(command) .. \"\\n\")\n"
    "    -- no response is expected\n"
    "  elseif command == \"setb\" or command == \"asetb\" then\n"
    "    _, _, _, file, line = string.find(params, \"^([a-z]+)%s+(.-)%s+(%d+)%s*$\")\n"
    "    if file and line then\n"
    "      -- if this is a file name, and not a file source\n"
    "      if not file:find('^\".*\"$') then\n"
    "        file = string.gsub(file, \"\\\\\", \"/\") -- convert slash\n"
    "        file = removebasedir(file, basedir)\n"
    "      end\n"
    "      client:send(\"SETB \" .. file .. \" \" .. line .. \"\\n\")\n"
    "      if command == \"asetb\" or client:receive() == \"200 OK\" then\n"
    "        set_breakpoint(file, line)\n"
    "      else\n"
    "        print(\"Error: breakpoint not inserted\")\n"
    "      end\n"
    "    else\n"
    "      print(\"Invalid command\")\n"
    "    end\n"
    "  elseif command == \"setw\" then\n"
    "    local _, _, exp = string.find(params, \"^[a-z]+%s+(.+)$\")\n"
    "    if exp then\n"
    "      client:send(\"SETW \" .. exp .. \"\\n\")\n"
    "      local answer = client:receive()\n"
    "      local _, _, watch_idx = string.find(answer, \"^200 OK (%d+)%s*$\")\n"
    "      if watch_idx then\n"
    "        watches[watch_idx] = exp\n"
    "        print(\"Inserted watch exp no. \" .. watch_idx)\n"
    "      else\n"
    "        local _, _, size = string.find(answer, \"^401 Error in Expression (%d+)$\")\n"
    "        if size then\n"
    "          local err = client:receive(tonumber(size)):gsub(\".-:%d+:%s*\",\"\")\n"
    "          print(\"Error: watch expression not set: \" .. err)\n"
    "        else\n"
    "          print(\"Error: watch expression not set\")\n"
    "        end\n"
    "      end\n"
    "    else\n"
    "      print(\"Invalid command\")\n"
    "    end\n"
    "  elseif command == \"delb\" or command == \"adelb\" then\n"
    "    _, _, _, file, line = string.find(params, \"^([a-z]+)%s+(.-)%s+(%d+)%s*$\")\n"
    "    if file and line then\n"
    "      -- if this is a file name, and not a file source\n"
    "      if not file:find('^\".*\"$') then\n"
    "        file = string.gsub(file, \"\\\\\", \"/\") -- convert slash\n"
    "        file = removebasedir(file, basedir)\n"
    "      end\n"
    "      client:send(\"DELB \" .. file .. \" \" .. line .. \"\\n\")\n"
    "      if command == \"adelb\" or client:receive() == \"200 OK\" then\n"
    "        remove_breakpoint(file, line)\n"
    "      else\n"
    "        print(\"Error: breakpoint not removed\")\n"
    "      end\n"
    "    else\n"
    "      print(\"Invalid command\")\n"
    "    end\n"
    "  elseif command == \"delallb\" then\n"
    "    local file, line = \"*\", 0\n"
    "    client:send(\"DELB \" .. file .. \" \" .. tostring(line) .. \"\\n\")\n"
    "    if client:receive() == \"200 OK\" then\n"
    "      remove_breakpoint(file, line)\n"
    "    else\n"
    "      print(\"Error: all breakpoints not removed\")\n"
    "    end\n"
    "  elseif command == \"delw\" then\n"
    "    local _, _, index = string.find(params, \"^[a-z]+%s+(%d+)%s*$\")\n"
    "    if index then\n"
    "      client:send(\"DELW \" .. index .. \"\\n\")\n"
    "      if client:receive() == \"200 OK\" then\n"
    "        watches[index] = nil\n"
    "      else\n"
    "        print(\"Error: watch expression not removed\")\n"
    "      end\n"
    "    else\n"
    "      print(\"Invalid command\")\n"
    "    end\n"
    "  elseif command == \"delallw\" then\n"
    "    for index, exp in pairs(watches) do\n"
    "      client:send(\"DELW \" .. index .. \"\\n\")\n"
    "      if client:receive() == \"200 OK\" then\n"
    "        watches[index] = nil\n"
    "      else\n"
    "        print(\"Error: watch expression at index \" .. index .. \" [\" .. exp .. \"] not removed\")\n"
    "      end\n"
    "    end\n"
    "  elseif command == \"eval\" or command == \"exec\"\n"
    "      or command == \"load\" or command == \"loadstring\"\n"
    "      or command == \"reload\" then\n"
    "    local _, _, exp = string.find(params, \"^[a-z]+%s+(.+)$\")\n"
    "    if exp or (command == \"reload\") then\n"
    "      if command == \"eval\" or command == \"exec\" then\n"
    "        exp = (exp:gsub(\"%-%-%[(=*)%[.-%]%1%]\", \"\") -- remove comments\n"
    "                  :gsub(\"%-%-.-\\n\", \" \") -- remove line comments\n"
    "                  :gsub(\"\\n\", \" \")) -- convert new lines\n"
    "        if command == \"eval\" then exp = \"return \" .. exp end\n"
    "        client:send(\"EXEC \" .. exp .. \"\\n\")\n"
    "      elseif command == \"reload\" then\n"
    "        client:send(\"LOAD 0 -\\n\")\n"
    "      elseif command == \"loadstring\" then\n"
    "        local _, _, _, file, lines = string.find(exp, \"^([\\\"'])(.-)%1%s+(.+)\")\n"
    "        if not file then\n"
    "           _, _, file, lines = string.find(exp, \"^(%S+)%s+(.+)\")\n"
    "        end\n"
    "        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\n"
    "        client:send(lines)\n"
    "      else\n"
    "        local file = io.open(exp, \"r\")\n"
    "        if not file and pcall(require, \"winapi\") then\n"
    "          -- if file is not open and winapi is there, try with a short path;\n"
    "          -- this may be needed for unicode paths on windows\n"
    "          winapi.set_encoding(winapi.CP_UTF8)\n"
    "          local shortp = winapi.short_path(exp)\n"
    "          file = shortp and io.open(shortp, \"r\")\n"
    "        end\n"
    "        if not file then return nil, nil, \"Cannot open file \" .. exp end\n"
    "        -- read the file and remove the shebang line as it causes a compilation error\n"
    "        local lines = file:read(\"*all\"):gsub(\"^#!.-\\n\", \"\\n\")\n"
    "        file:close()\n"
    "\n"
    "        local file = string.gsub(exp, \"\\\\\", \"/\") -- convert slash\n"
    "        file = removebasedir(file, basedir)\n"
    "        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\n"
    "        if #lines > 0 then client:send(lines) end\n"
    "      end\n"
    "      while true do\n"
    "        local params, err = client:receive()\n"
    "        if not params then\n"
    "          return nil, nil, \"Debugger connection \" .. (err or \"error\")\n"
    "        end\n"
    "        local done = true\n"
    "        local _, _, status, len = string.find(params, \"^(%d+).-%s+(%d+)%s*$\")\n"
    "        if status == \"200\" then\n"
    "          len = tonumber(len)\n"
    "          if len > 0 then\n"
    "            local status, res\n"
    "            local str = client:receive(len)\n"
    "            -- handle serialized table with results\n"
    "            local func, err = loadstring(str)\n"
    "            if func then\n"
    "              status, res = pcall(func)\n"
    "              if not status then err = res\n"
    "              elseif type(res) ~= \"table\" then\n"
    "                err = \"received \"..type(res)..\" instead of expected 'table'\"\n"
    "              end\n"
    "            end\n"
    "            if err then\n"
    "              print(\"Error in processing results: \" .. err)\n"
    "              return nil, nil, \"Error in processing results: \" .. err\n"
    "            end\n"
    "            print(unpack(res))\n"
    "            return res[1], res\n"
    "          end\n"
    "        elseif status == \"201\" then\n"
    "          _, _, file, line = string.find(params, \"^201 Started%s+(.-)%s+(%d+)%s*$\")\n"
    "        elseif status == \"202\" or params == \"200 OK\" then\n"
    "          -- do nothing; this only happens when RE/LOAD command gets the response\n"
    "          -- that was for the original command that was aborted\n"
    "        elseif status == \"204\" then\n"
    "          local _, _, stream, size = string.find(params, \"^204 Output (%w+) (%d+)$\")\n"
    "          if stream and size then\n"
    "            local msg = client:receive(tonumber(size))\n"
    "            print(msg)\n"
    "            if outputs[stream] then outputs[stream](msg) end\n"
    "            -- this was just the output, so go back reading the response\n"
    "            done = false\n"
    "          end\n"
    "        elseif status == \"401\" then\n"
    "          len = tonumber(len)\n"
    "          local res = client:receive(len)\n"
    "          print(\"Error in expression: \" .. res)\n"
    "          return nil, nil, res\n"
    "        else\n"
    "          print(\"Unknown error\")\n"
    "          return nil, nil, \"Debugger error: unexpected response after EXEC/LOAD '\" .. params .. \"'\"\n"
    "        end\n"
    "        if done then break end\n"
    "      end\n"
    "    else\n"
    "      print(\"Invalid command\")\n"
    "    end\n"
    "  elseif command == \"listb\" then\n"
    "    for l, v in pairs(breakpoints) do\n"
    "      for f in pairs(v) do\n"
    "        print(f .. \": \" .. l)\n"
    "      end\n"
    "    end\n"
    "  elseif command == \"listw\" then\n"
    "    for i, v in pairs(watches) do\n"
    "      print(\"Watch exp. \" .. i .. \": \" .. v)\n"
    "    end\n"
    "  elseif command == \"suspend\" then\n"
    "    client:send(\"SUSPEND\\n\")\n"
    "  elseif command == \"stack\" then\n"
    "    client:send(\"STACK\\n\")\n"
    "    local resp = client:receive()\n"
    "    local _, _, status, res = string.find(resp, \"^(%d+)%s+%w+%s+(.+)%s*$\")\n"
    "    if status == \"200\" then\n"
    "      local func, err = loadstring(res)\n"
    "      if func == nil then\n"
    "        print(\"Error in stack information: \" .. err)\n"
    "        return nil, nil, err\n"
    "      end\n"
    "      local ok, stack = pcall(func)\n"
    "      if not ok then\n"
    "        print(\"Error in stack information: \" .. stack)\n"
    "        return nil, nil, stack\n"
    "      end\n"
    "      for _,frame in ipairs(stack) do\n"
    "        print(mobdebug.line(frame[1], {comment = false}))\n"
    "      end\n"
    "      return stack\n"
    "    elseif status == \"401\" then\n"
    "      local _, _, len = string.find(resp, \"%s+(%d+)%s*$\")\n"
    "      len = tonumber(len)\n"
    "      local res = len > 0 and client:receive(len) or \"Invalid stack information.\"\n"
    "      print(\"Error in expression: \" .. res)\n"
    "      return nil, nil, res\n"
    "    else\n"
    "      print(\"Unknown error\")\n"
    "      return nil, nil, \"Debugger error: unexpected response after STACK\"\n"
    "    end\n"
    "  elseif command == \"output\" then\n"
    "    local _, _, stream, mode = string.find(params, \"^[a-z]+%s+(%w+)%s+([dcr])%s*$\")\n"
    "    if stream and mode then\n"
    "      client:send(\"OUTPUT \"..stream..\" \"..mode..\"\\n\")\n"
    "      local resp = client:receive()\n"
    "      local _, _, status = string.find(resp, \"^(%d+)%s+%w+%s*$\")\n"
    "      if status == \"200\" then\n"
    "        print(\"Stream \"..stream..\" redirected\")\n"
    "        outputs[stream] = type(options) == 'table' and options.handler or nil\n"
    "      else\n"
    "        print(\"Unknown error\")\n"
    "        return nil, nil, \"Debugger error: can't redirect \"..stream\n"
    "      end\n"
    "    else\n"
    "      print(\"Invalid command\")\n"
    "    end\n"
    "  elseif command == \"basedir\" then\n"
    "    local _, _, dir = string.find(params, \"^[a-z]+%s+(.+)$\")\n"
    "    if dir then\n"
    "      dir = string.gsub(dir, \"\\\\\", \"/\") -- convert slash\n"
    "      if not string.find(dir, \"/$\") then dir = dir .. \"/\" end\n"
    "\n"
    "      local remdir = dir:match(\"\\t(.+)\")\n"
    "      if remdir then dir = dir:gsub(\"/?\\t.+\", \"/\") end\n"
    "      basedir = dir\n"
    "\n"
    "      client:send(\"BASEDIR \"..(remdir or dir)..\"\\n\")\n"
    "      local resp, err = client:receive()\n"
    "      if not resp then\n"
    "        print(\"Unknown error: \"..err)\n"
    "        return nil, nil, \"Debugger connection closed\"\n"
    "      end\n"
    "      local _, _, status = string.find(resp, \"^(%d+)%s+%w+%s*$\")\n"
    "      if status == \"200\" then\n"
    "        print(\"New base directory is \" .. basedir)\n"
    "      else\n"
    "        print(\"Unknown error\")\n"
    "        return nil, nil, \"Debugger error: unexpected response after BASEDIR\"\n"
    "      end\n"
    "    else\n"
    "      print(basedir)\n"
    "    end\n"
    "  elseif command == \"help\" then\n"
    "    print(\"setb <file> <line>    -- sets a breakpoint\")\n"
    "    print(\"delb <file> <line>    -- removes a breakpoint\")\n"
    "    print(\"delallb               -- removes all breakpoints\")\n"
    "    print(\"setw <exp>            -- adds a new watch expression\")\n"
    "    print(\"delw <index>          -- removes the watch expression at index\")\n"
    "    print(\"delallw               -- removes all watch expressions\")\n"
    "    print(\"run                   -- runs until next breakpoint\")\n"
    "    print(\"step                  -- runs until next line, stepping into function calls\")\n"
    "    print(\"over                  -- runs until next line, stepping over function calls\")\n"
    "    print(\"out                   -- runs until line after returning from current function\")\n"
    "    print(\"listb                 -- lists breakpoints\")\n"
    "    print(\"listw                 -- lists watch expressions\")\n"
    "    print(\"eval <exp>            -- evaluates expression on the current context and returns its value\")\n"
    "    print(\"exec <stmt>           -- executes statement on the current context\")\n"
    "    print(\"load <file>           -- loads a local file for debugging\")\n"
    "    print(\"reload                -- restarts the current debugging session\")\n"
    "    print(\"stack                 -- reports stack trace\")\n"
    "    print(\"output stdout <d|c|r> -- capture and redirect io stream (default|copy|redirect)\")\n"
    "    print(\"basedir [<path>]      -- sets the base path of the remote application, or shows the current one\")\n"
    "    print(\"done                  -- stops the debugger and continues application execution\")\n"
    "    print(\"exit                  -- exits debugger and the application\")\n"
    "  else\n"
    "    local _, _, spaces = string.find(params, \"^(%s*)$\")\n"
    "    if spaces then\n"
    "      return nil, nil, \"Empty command\"\n"
    "    else\n"
    "      print(\"Invalid command\")\n"
    "      return nil, nil, \"Invalid command\"\n"
    "    end\n"
    "  end\n"
    "  return file, line\n"
    "end\n"
    "\n"
    "-- Starts debugging server\n"
    "local function listen(host, port)\n"
    "  host = host or \"*\"\n"
    "  port = port or mobdebug.port\n"
    "\n"
    "  local socket = require \"socket\"\n"
    "\n"
    "  print(\"Lua Remote Debugger\")\n"
    "  print(\"Run the program you wish to debug\")\n"
    "\n"
    "  local server = socket.bind(host, port)\n"
    "  local client = server:accept()\n"
    "\n"
    "  client:send(\"STEP\\n\")\n"
    "  client:receive()\n"
    "\n"
    "  local breakpoint = client:receive()\n"
    "  local _, _, file, line = string.find(breakpoint, \"^202 Paused%s+(.-)%s+(%d+)%s*$\")\n"
    "  if file and line then\n"
    "    print(\"Paused at file \" .. file )\n"
    "    print(\"Type 'help' for commands\")\n"
    "  else\n"
    "    local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)%s*$\")\n"
    "    if size then\n"
    "      print(\"Error in remote application: \")\n"
    "      print(client:receive(size))\n"
    "    end\n"
    "  end\n"
    "\n"
    "  while true do\n"
    "    io.write(\"> \")\n"
    "    local file, line, err = handle(io.read(\"*line\"), client)\n"
    "    if not file and not err then break end -- completed debugging\n"
    "  end\n"
    "\n"
    "  client:close()\n"
    "end\n"
    "\n"
    "local cocreate\n"
    "local function coro()\n"
    "  if cocreate then return end -- only set once\n"
    "  cocreate = cocreate or coroutine.create\n"
    "  coroutine.create = function(f, ...)\n"
    "    return cocreate(function(...)\n"
    "      mobdebug.on()\n"
    "      return f(...)\n"
    "    end, ...)\n"
    "  end\n"
    "end\n"
    "\n"
    "local moconew\n"
    "local function moai()\n"
    "  if moconew then return end -- only set once\n"
    "  moconew = moconew or (MOAICoroutine and MOAICoroutine.new)\n"
    "  if not moconew then return end\n"
    "  MOAICoroutine.new = function(...)\n"
    "    local thread = moconew(...)\n"
    "    -- need to support both thread.run and getmetatable(thread).run, which\n"
    "    -- was used in earlier MOAI versions\n"
    "    local mt = thread.run and thread or getmetatable(thread)\n"
    "    local patched = mt.run\n"
    "    mt.run = function(self, f, ...)\n"
    "      return patched(self,  function(...)\n"
    "        mobdebug.on()\n"
    "        return f(...)\n"
    "      end, ...)\n"
    "    end\n"
    "    return thread\n"
    "  end\n"
    "end\n"
    "\n"
    "-- make public functions available\n"
    "mobdebug.setbreakpoint = set_breakpoint\n"
    "mobdebug.removebreakpoint = remove_breakpoint\n"
    "mobdebug.listen = listen\n"
    "mobdebug.loop = loop\n"
    "mobdebug.scratchpad = scratchpad\n"
    "mobdebug.handle = handle\n"
    "mobdebug.connect = connect\n"
    "mobdebug.start = start\n"
    "mobdebug.on = on\n"
    "mobdebug.off = off\n"
    "mobdebug.moai = moai\n"
    "mobdebug.coro = coro\n"
    "mobdebug.done = done\n"
    "mobdebug.pause = function() step_into = true end\n"
    "mobdebug.yield = nil -- callback\n"
    "mobdebug.onexit = os and os.exit or done\n"
    "mobdebug.basedir = function(b) if b then basedir = b end return basedir end\n"
    "\n"
    "return mobdebug\n"
};

static int luaopen_lua_mobdebug(lua_State *L) {
    luaL_loadstring(L, lua_mobdebug);
    return 1;
}

static luaL_Reg luasocket_scripts_modules[] = {
    {"mobdebug", luaopen_lua_mobdebug},
    {NULL, NULL}
};

void luaopen_mobdebug_scripts(void* L)
{
    
    void luaopen_luasocket_scripts(lua_State* L);
    luaopen_luasocket_scripts(L);
    
    luaL_Reg* lib = luasocket_scripts_modules;
    lua_getglobal(L, "package");
    lua_getfield(L, -1, "preload");
    for (; lib->func; lib++)
    {
        lib->func(L);
        lua_setfield(L, -2, lib->name);
    }
    lua_pop(L, 2);
}

                                                           
